#burpsuite


## 1.1. Inspección del tráfico web

Al analizar una aplicación web desconocida, siempre debemos comenzar con una inspección del tráfico. Una aplicación web presenta diversos elementos de interfaz y realiza varias transacciones de red.

Como investigadores, siempre nos interesa obtener la mayor cantidad de información posible sobre nuestros objetivos y, en este caso, un proxy de aplicación web es una herramienta indispensable. Podemos usar un buen proxy para capturar las solicitudes relevantes del cliente y las respuestas del servidor, y manipular fácilmente una solicitud específica de forma arbitraria.

En este curso, utilizaremos principalmente la edición comunitaria de Burp Suite (instalada por defecto en Kali Linux), que nos proporciona todo lo necesario para llevar a cabo una recopilación exhaustiva de información y la manipulación de solicitudes HTTP.

### 1.1.1. Proxy de Burp Suite

Podemos iniciar Burp Suite en Kali a través del menú de inicio. Una vez que lo iniciemos, es posible que recibamos una notificación que indique que Burp Suite no se ha probado con nuestra versión actual de Java (Figura 1).

![[Pasted image 20251114012639.png]]

Dado que el equipo de Kali siempre prueba Burp Suite en la versión de Java que viene con el sistema operativo, podemos ignorar esta advertencia sin problemas.
La primera vez que ejecutemos Burp Suite, nos pedirá que aceptemos los Términos y Condiciones.

![[Pasted image 20251114012706.png]]

Podemos aceptar los Términos y Condiciones haciendo clic en _Acepto_ después de decidir si deseamos enviar comentarios anónimos o no.

La siguiente ventana nos ofrece la posibilidad de iniciar un nuevo proyecto o restaurar uno guardado previamente. La capacidad de usar archivos de proyecto es una función de Burp Suite Professional. No necesitamos usar esta función para este curso, así que dejaremos seleccionada la opción _«Proyecto temporal»_ y continuaremos.

![[Pasted image 20251114012736.png]]

La última ventana ofrece la opción de cargar una configuración personalizada o aceptar la predeterminada. Burp Suite nos permite personalizar y optimizar nuestro flujo de trabajo y configuración mediante estas opciones. Por ahora, utilizaremos el perfil predeterminado de Burp Suite y haremos clic en Iniciar Burp .

![[Pasted image 20251114012825.png]]


Una vez iniciado Burp Suite, podemos comprobar que nuestro servicio proxy está funcionando consultando el registro de eventos en la esquina inferior izquierda del panel de control. Se mostrará un mensaje similar al siguiente:

![[Pasted image 20251114012841.png]]


Ahora que el servicio proxy está en funcionamiento, necesitamos configurar un navegador. Burp Suite incluye un navegador Chromium integrado que viene preconfigurado para redirigir el tráfico a través del proxy de Burp Suite. Podemos abrirlo haciendo clic en la pestaña «Proxy» y luego en la pestaña «Interceptar».

![[Pasted image 20251114012911.png]]

Podemos abrir el navegador Chromium integrado haciendo clic en cualquiera de los botones _"Abrir navegador"_ de esta pestaña.

Ahora que nuestro proxy está configurado, lo probaremos brevemente. En este caso, accederemos a la máquina virtual del laboratorio que aloja una versión vulnerable de la aplicación web [_Concord_](https://concord.walmartlabs.com/)
 .
Tenga en cuenta que, para este curso, hemos creado entradas en el archivo hosts de nuestra máquina de ataque Kali Linux que nos permiten referirnos a las máquinas del laboratorio por su nombre.
```bash
kali@kali:~$ cat /etc/hosts
127.0.0.1	localhost
127.0.1.1	kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
# AWAE lab machines
192.168.121.103 atutor
192.168.121.112 bassmaster
192.168.121.113 manageengine
192.168.121.120 dnn
192.168.121.123 erpnext
192.168.121.126 opencrx
192.168.121.129 openitcockpit
192.168.121.132 concord
192.168.121.135 apigateway
192.168.121.138 chips
192.168.121.247 photog
192.168.121.247 sqeakr
192.168.121.249 docedit
192.168.121.251 answers
192.168.121.253 debugger 
```


![[Pasted image 20251114013151.png]]

```
student : studentlab
```

![[Pasted image 20251114013223.png]]

Si ahora intentamos acceder a la URL **http://concord:8001/** , observaremos que el navegador no completa la solicitud ya que Burp Suite activa la función _Intercept_ de forma predeterminada.
![[Pasted image 20251114013319.png]]
Como su nombre indica, esta función intercepta las solicitudes enviadas al proxy. A continuación, permite inspeccionar y reenviar una solicitud al destino o descartarla mediante los botones correspondientes, como se muestra en la figura 8.

![[Pasted image 20251114013332.png]]

Para los fines de este módulo, podemos desactivar esta función de forma segura haciendo clic en _"Interceptar está activado_ ". El texto del botón se actualizará a "Interceptar está desactivado".

La pestaña _de historial HTTP_ es bastante autoexplicativa: aquí es donde Burp Suite muestra todo el historial de la sesión, que incluye todas las solicitudes y respuestas enviadas a través de él.

![[Pasted image 20251114013352.png]]

Excelente. Hemos verificado que Burp Suite está capturando nuestro tráfico de navegación.

### 1.1.2. Uso de Burp Suite con otros navegadores

Antes de continuar con otras herramientas de Burp Suite, veamos cómo configurar otro navegador para usar Burp Suite como proxy. En Firefox, podemos hacerlo accediendo a **about:preferences#advanced** , desplazándonos hacia abajo hasta Configuración de red y haciendo clic en _Configuración_ .

Aquí seleccionaremos la opción _Manual_ , configurando la dirección IP y el puerto de escucha adecuados. En nuestro caso, el proxy y el navegador se encuentran en el mismo servidor, por lo que utilizaremos la interfaz de bucle invertido y especificaremos el puerto 8080. Sin embargo, si planeáramos usar el proxy para interceptar el tráfico de varias máquinas, usaríamos la dirección IP pública de la máquina que ejecuta el proxy para esta configuración.

Finalmente, también queremos marcar la opción _"Usar este servidor proxy para todos los protocolos"_ para asegurarnos de que podemos interceptar todas las solicitudes mientras probamos la aplicación objetivo.

![Figura 10: Configuración de red de Firefox](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/5be21d2df4c43d524be69ba0a65f8836-tm_firefox_cfg_01.png)

Figura 10: Configuración de red de Firefox

Tenga en cuenta que, una vez configurado Firefox de esta manera, necesitaremos tener Burp Suite en ejecución para acceder a cualquier sitio web. Para dejar de usar Burp Suite como proxy, debemos volver a la configuración de conexión y seleccionar « _Usar la configuración de proxy del sistema_». Como alternativa, podemos usar alguna extensión del navegador (como FoxyProxy) para cambiar entre las configuraciones del servidor proxy.

### 1.1.3. Scope de Burp Suite


Burp Suite nos permite establecer un ámbito de recopilación. Ahora podemos hacerlo haciendo clic con el botón derecho en cualquier solicitud de Concord (con una URL que termine con una barra diagonal) y seleccionando « _Add to Scope»_ .

Tenga en cuenta que realizar esta acción en una solicitud de URL de dominio de nivel superior agregará todo el dominio al ámbito. En cambio, realizar esta acción en una página más específica de una aplicación web determinada solo agregará esa página al ámbito.

![[Pasted image 20251114002613.png]]

Una vez que establecemos el ámbito, se nos da la opción de dejar de capturar elementos que no están dentro del ámbito. Elegiremos _Sí_.

![[Pasted image 20251114002914.png]]

Ahora que hemos añadido el servidor Concord a nuestro scope, podemos cambiar la configuración del filtro _del historial HTTP_ para que muestre solo los elementos que lo componen. Para ello, haremos clic en el cuadro de filtro, seleccionaremos « _Mostrar solo los elementos del ámbito»_ y haremos clic fuera del cuadro de filtro.

![[Pasted image 20251114002956.png]]

Una vez actualizado el filtro, la solicitud a **[content-autofill.googleapis.com](http://content-autofill.googleapis.com)** queda oculta, como se muestra en la Figura 14. Configurar el alcance en Burp Suite puede eliminar el "ruido" causado por los navegadores que intentan actualizarse o descargar otros recursos.

![[Pasted image 20251114003021.png]]

Podemos verificar que nuestro ámbito se ha configurado correctamente cambiando a la pestaña _Objetivo_ y luego seleccionando la subpestaña _Ámbito_.

![[Pasted image 20251114003040.png]]

El ámbito de destino muestra la URL base del servidor Concord con una marca de verificación que indica que está habilitado.

### 1.1.4. Repetidor y comparador Burp Suite

Al inspeccionar aplicaciones web, a menudo necesitamos determinar cómo los cambios granulares en nuestras solicitudes HTTP afectan la respuesta que devuelve un servidor web. En esos casos, podemos usar la herramienta Burp Suite _Repeater_ para realizar cambios arbitrarios y muy precisos en una solicitud capturada y luego reenviarla al servidor web de destino.

Vamos a probarlo. Volvamos a la pestaña _Proxy_ > _Historial HTTP_ y usemos la solicitud a **/api/service/console/whoami** . Hagamos clic con el botón derecho y seleccionemos _Enviar al repetidor_ (Figura 16).

![Figura 16: Burp Suite: Enviar a repetidor](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/496c96afcba9860f99c1be8ff3c2de6d-tm_burp_repeater_01.png)

Figura 16: Burp Suite: Enviar a repetidor

Una vez en la pestaña _Repetidor_ , haremos clic en _Enviar_ para reenviar nuestra solicitud original (sin modificar). La respuesta establecerá una base de referencia con la que podremos evaluar las solicitudes posteriores, modificadas arbitrariamente, a la misma URL y sus respuestas correspondientes.

![Figura 17: Solicitud de reenvío del repetidor de Burp Suite](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/ba6c00636c7fdcb14cad7c5c896c2183-tm_burp_repeater_02.png)

Figura 17: Solicitud de reenvío del repetidor de Burp Suite

Ahora que tenemos una respuesta de referencia, haremos un pequeño cambio en nuestra solicitud original. Un aspecto interesante de la respuesta de referencia es que incluye varias cabeceras _de control de acceso_ . Estas cabeceras suelen indicar que la aplicación admite [_el intercambio de recursos de origen cruzado_](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) (CORS). Nuestra solicitud original no incluía una cabecera _de origen_ . Veamos qué sucede si enviamos una. Agregaremos "Origin: hello.world" a la solicitud y luego haremos clic en _Enviar_ .

![Figura 18: Burp Suite envía una solicitud modificada](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/679f7af28e71c75f1315995c48e4fb62-tm_burp_repeater_03.png)

Figura 18: Burp Suite envía una solicitud modificada

En la figura 18, la respuesta tiene un valor _de Access-Control-Allow-Origin_ diferente , que refleja el valor que enviamos. Para comparar mejor las respuestas, podemos usar la función _Comparador_ haciendo clic con el botón derecho en la respuesta y seleccionando _Enviar al comparador_ .

![Figura 19: Burp Suite envía una respuesta al comparador](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/132431bbd1f83b83c4cbcbbbe5a4f769-tm_burp_repeater_04.png)

Figura 19: Burp Suite envía una respuesta al comparador

Antes de cambiar a la pestaña _Comparador_ , volvamos a nuestra solicitud original (Figura 20) y _enviemos al comparador_ para que tengamos dos respuestas diferentes que podamos comparar (Figura 19).

![Figura 20: Solicitud y respuesta anteriores del repetidor de Burp Suite](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/3e4090660326fb1296e39200c6c0c118-tm_burp_repeater_05.png)

Figura 20: Solicitud y respuesta anteriores del repetidor de Burp Suite

![Figura 19: Burp Suite envía una segunda respuesta al comparador.](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/d7ab7aced2eb2d0f3a400c3fdc897db0-tm_burp_repeater_06.png)

Figura 19: Burp Suite envía una segunda respuesta al comparador.

Ahora podemos cambiar a la pestaña _Comparador_ , donde Burp Suite ha resaltado automáticamente las diferentes respuestas en sus respectivas ventanas. En este punto, tenemos la opción de comparar las respuestas para detectar diferencias en _Palabras_ o _Bytes_ . Elegiremos la opción _Palabras_ (Figura 21), ya que este ejemplo no incluye una respuesta binaria.

![Figura 21: Pestaña Comparador de Burp Suite](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/46c523d269268fb5510a9560262e7b1d-tm_burp_comparer_01.png)

Figura 21: Pestaña Comparador de Burp Suite

Burp Suite muestra los resultados de la comparación en una ventana dedicada (Figura 22), resaltando cada cambio con un código de color para _Modificado_ , _Eliminado_ y _Agregado_ .

![Figura 22: Pestaña Comparador de Burp Suite - comparación de palabras](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/4b38e197d8812c8d2537595342e9cc0a-tm_burp_comparer_02.png)

Figura 22: Pestaña Comparador de Burp Suite - comparación de palabras

En este ejemplo, Burp Suite resaltó las diferencias _de Modified_ y _Deleted_ entre las dos respuestas. Anteriormente identificamos el cambio en el valor de _Access-Control-Allow-Origin , pero Comparer también ha resaltado que los encabezados_ _Vary_ y _Access-Control-Allow-Credentials_ están presentes en la primera respuesta, pero no en la segunda.

Aunque este es un ejemplo muy simple, muestra cómo las herramientas _Repeater_ y _Comparer_
pueden ser extremadamente valiosas al probar una aplicación web.

### 1.1.5. Decodificador de Burp Suite

Al analizar aplicaciones web modernas, a menudo encontramos datos codificados en las solicitudes y respuestas HTTP. Afortunadamente, Burp Suite cuenta con una herramienta de decodificación versátil y fácil de integrar en nuestro flujo de trabajo.

Como ejemplo, abramos nuestro navegador e intentemos iniciar sesión en la aplicación Concord con "test" como nombre de usuario y contraseña. Esto devuelve el mensaje "Nombre de usuario o contraseña no válidos". Volvamos a Burp Suite. Curiosamente, nuestro navegador envió una solicitud GET a **/api/service/console/whoami** . Las solicitudes de inicio de sesión suelen ser POST. Hagamos clic en la nueva solicitud.

La nueva solicitud GET incluía una cabecera _de autorización_ con el valor "Basic dGVzdDp0ZXN0". Si seleccionamos el texto "dGVzdDp0ZXN0", la herramienta Inspector detectará que está codificado en base64 y mostrará el texto decodificado en la parte derecha de la ventana de Burp Suite.

![Figura 23: Solicitud de inicio de sesión de Burp Suite](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/fba54ae93c9751bfed3f257057259afe-tm_burp_decoder_01.png)

La herramienta Inspector es útil para decodificar rápidamente los tipos de codificación más comunes en la pestaña del historial HTTP. La herramienta Decoder de Burp Suite es una versión más potente de la herramienta Inspector. Probémosla haciendo clic con el botón derecho en el texto resaltado y seleccionando _Enviar a Decoder_ .

![Figura 24: Función Enviar al decodificador de Burp Suite](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/72f6805bc8509fc457396a3bd549fc6e-tm_burp_decoder_02.png)


Ahora, si cambiamos a la pestaña _Decodificador_ , podemos elegir la opción _Decodificar como_ a la derecha y seleccionar _Base64_ para el esquema de codificación (Figura 25).

![Figura 25: Burp Suite decodificando los valores seleccionados](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/8bf6f080436cbef5a56cd11f90cb9ce9-tm_burp_decoder_03.png)

Como resultado, se abre un segundo cuadro de texto con el valor decodificado debajo de nuestros datos originales.

![Figura 26: Burp Suite decodificó correctamente los valores seleccionados](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/90735a5c3c1fe160da6bea7b339a75ad-tm_burp_decoder_04.png)

El valor decodificado coincide con la salida de la herramienta Inspector, pero la herramienta Decoder permite opciones para codificación, decodificación y hash.

Hasta ahora, solo hemos mostrado algunas funciones básicas, aunque útiles, de Burp Suite. Esta herramienta contiene muchas más funciones que pueden resultar muy útiles al investigar aplicaciones web modernas y complejas.

#### Ceremonias

1. Tómese un tiempo para familiarizarse con el proxy de Burp Suite y sus diversas funcionalidades.
2. Dedica tiempo a aprender más sobre las [funciones básicas de Burp Suite](https://portswigger.net/burp/documentation) , ya que este conocimiento mejorará la eficiencia de tu flujo de trabajo.

## 1.2. Interacción con oyentes web mediante Python

En este curso, crearemos exploits complejos para aplicaciones web en Python.

Sin embargo, Python ha experimentado un cambio significativo recientemente. A partir de enero de 2020, Python 2 dejará de tener soporte y será reemplazado oficialmente por Python 3. No obstante, muchos sistemas operativos, incluido Debian, incluyen Python 2 como paquete binario _de Python_ y Python 3 como _python3_ . Por esta razón, cuando usamos **Python** para ejecutar un script en este curso, estamos usando Python 2, y cuando usamos **python3** , estamos usando Python 3. Además, ciertas bibliotecas incluidas por defecto en Python 2 se eliminarán. Para compensar esto, proporcionamos el paquete _offsec-awae (que se instala con_ **`sudo apt-get install offsec-awae`** ) para instalar las bibliotecas faltantes.

Al usar Python, a menudo utilizaremos la biblioteca _requests_ para interactuar con nuestras aplicaciones web. Si bien existen numerosas guías _de requests_ bien escritas (incluida la [documentación oficial](http://docs.python-requests.org/en/master/) ), en este módulo mostraremos algunos ejemplos básicos.

Por ejemplo, el siguiente script enviará una solicitud HTTP al servidor web [ManageEngine](https://www.manageengine.com/)
en los laboratorios y mostrará los detalles de la respuesta correspondiente:
[[manageengine_web_requests.py]]
```python
import requests
from colorama import Fore, Back, Style

requests.packages.urllib3.\
disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
def format_text(title,item):
   cr = '\r\n'
   section_break = cr +  "*" * 20 + cr
   item = str(item)
   text = Style.BRIGHT + Fore.RED + title + Fore.RESET + section_break + item + section_break
   return text

 r = requests.get('https://manageengine:8443/',verify=False)
 print(format_text('r.status_code is: ',r.status_code))
 print(format_text('r.headers is: ',r.headers))
 print(format_text('r.cookies is: ',r.cookies))
 print(format_text('r.text is: ',r.text))
```

En las líneas 1 y 2 del Listado 2, importamos el módulo _requests_ , así como un módulo para mostrar la salida en diferentes colores. Las líneas 4 y 5 deshabilitan la visualización de advertencias de certificado cuando se realizan solicitudes a sitios web que utilizan certificados no seguros. Esto puede ser útil en escenarios donde las aplicaciones web objetivo utilizan certificados autofirmados, como ocurre en los laboratorios de AWAE.

Las líneas 6 a 11 implementan una función para mostrar las cabeceras y el cuerpo de la respuesta de forma organizada. En la línea 13, asignamos a _`r`_ el resultado de una solicitud GET al servidor web ManageEngine en los laboratorios. Observe que en nuestra solicitud, establecemos el indicador de verificación en "False". Esto impide que la biblioteca verifique el certificado SSL/TLS. Finalmente, las líneas 14 a 17 muestran cómo acceder a algunos componentes comunes de una respuesta del servidor HTTP.

Guardemos este script como **manageengine_web_request.py**, ejecutémoslo y comprobemos los detalles de la respuesta del servidor web:

![[Pasted image 20251114015004.png]]La solicitud fue exitosa y se puede acceder fácilmente a las diferentes partes de la respuesta HTTP como propiedades del objeto Python ( _r_ ).

Es posible que necesitemos depurar las solicitudes generadas por nuestros scripts de Python de prueba de concepto. Afortunadamente, la biblioteca _requests_ incluye soporte para proxies. Para usarlo, solo necesitamos agregar un diccionario de Python a nuestro script que contenga la dirección IP, el puerto y el protocolo del proxy, que se utilizarán en la llamada a la función _requests.get_ . Actualicemos nuestro script para incluirlo.
[[manageengine_web_requests.py]]
```python
import requests
from colorama import Fore, Back, Style

requests.packages.urllib3.\
disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)
proxies = {'http':'http://127.0.0.1:8080','https':'http://127.0.0.1:8080'}
def format_text(title,item):
   cr = '\r\n'
   section_break = cr +  "*" * 20 + cr
   item = str(item)
   text = Style.BRIGHT + Fore.RED + title + Fore.RESET + section_break + item + section_break
   return text

 r = requests.get('https://manageengine:8443/',verify=False, proxies=proxies)
 print(format_text('r.status_code is: ',r.status_code))
 print(format_text('r.headers is: ',r.headers))
 print(format_text('r.cookies is: ',r.cookies))
 print(format_text('r.text is: ',r.text))
```
El script actualizado genera respuestas similares a las que se muestran en la Lista 3. Sin embargo, esta vez deberíamos poder localizar nuestra solicitud/respuesta en la pestaña Historial de Burp Suite.
![[Pasted image 20251114015254.png]]Lamentablemente, tras ejecutar nuestro script, Burp Suite sigue mostrando únicamente las solicitudes al servidor web de Concord (Figura 27). Esto se debe a que olvidamos añadir el destino ManageEngine a nuestro ámbito. La solución es sencilla, pero primero debemos volver a habilitar la captura de elementos fuera del ámbito en la pestaña _Proxy_ > _Historial HTTP,_ donde haremos clic en _Volver a habilitar,_ como se muestra en la Figura 28.
![[Pasted image 20251114015316.png]]Ahora podemos volver a ejecutar nuestro script de Python, volver a la pestaña _Destino_ > _Mapa del sitio_ , hacer clic con el botón derecho en la URL de ManageEngine y seleccionar _Agregar al ámbito_ (Figura 29).

![[Pasted image 20251114022532.png]]
Finalmente, podemos navegar a la pestaña _del historial HTTP_ , donde podemos inspeccionar la solicitud capturada de ManageEngine.
![[Pasted image 20251114022551.png]]

En este punto, también podríamos repetir el paso de la Figura 13, para mostrar solo los elementos dentro del alcance en nuestro historial.
Aunque el ejemplo anterior es bastante simple, nos proporciona un punto de partida para los scripts de prueba de concepto que desarrollaremos en módulos posteriores.
#### Ceremonias

1. Repita los pasos descritos en esta sección y asegúrese de poder interceptar las solicitudes HTTP del script de prueba de concepto.
2. Familiarícese con la biblioteca _requests_ de Python, ya que la utilizaremos ampliamente en los scripts complejos que crearemos en módulos posteriores.

## 1.3. Recuperación del código fuente

Como mencionamos en la introducción, debemos aprender a recuperar el código fuente de aplicaciones web escritas en lenguajes compilados. En este curso, nos centraremos principalmente en la recuperación de código fuente de Java y .NET, ya que están directamente relacionadas con las aplicaciones vulnerables que analizaremos.

### 1.3.1. Código .NET administrado
Más adelante en el curso, analizaremos una versión vulnerable de la aplicación web [DotNetNuke](https://www.dnnsoftware.com/) .NET. Esto implica que necesitaremos descompilar archivos ejecutables .NET administrados. Nuevamente, existen diversas herramientas que podemos usar para lograrlo, algunas de las cuales incluso se integran perfectamente con Visual Studio. La mayoría de los descompiladores .NET de uso común también pueden utilizarse como depuradores.

Dicho esto, utilizaremos el descompilador y depurador gratuito [_dnSpy_](https://github.com/0xd4d/dnSpy) para este propósito, ya que nos proporciona todo lo necesario. En concreto, _dnSpy_ utiliza el motor de descompilación [_ILSpy_](https://github.com/icsharpcode/ILSpy) para extraer el código fuente de un módulo .NET compilado.

#### Descompilación

Vamos a usar un programa sencillo en C# para demostrar un flujo de trabajo muy básico para descompilar ejecutables .NET.

Primero, nos conectaremos a la máquina del laboratorio DNN a través de escritorio remoto desde Kali. Las credenciales se encuentran en el material del curso.

```
xfreerdp /v:dnn /u:administrator /p:studentlab /cert:ignore /sec:rdp /dynamic-resolution
```

A continuación, usemos Notepad++ para crear un archivo de texto en el escritorio de la máquina virtual de Windows con el siguiente código:

```c#
using System;

namespace dotnetapp
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("What is your favourite Web Application                                           Language?");
            String answer = Console.ReadLine();
            Console.WriteLine("Your answer was: " + answer + "\r\n");
        }
    }
}
```

Guardaremos este archivo como **test.cs.** Para compilarlo, utilizaremos el compilador [**csc.exe**](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/command-line-building-with-csc-exe) del framework .NET.

```powershell
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe test.cs
```

![[Pasted image 20251114094112.png]]

Una vez creado nuestro **archivo test.exe** , ejecutémoslo para asegurarnos de que funciona correctamente.

```powerhsell
C:\Users\Administrator\Desktop> test.exe
What's your favorite web application language?
C-Sharp
Your answer was: C-Sharp
```

![[Pasted image 20251114094228.png]]

Ahora podemos abrir dnSpy e intentar descompilar el código de este ejecutable. Arrastraremos el archivo **test.exe** a la ventana de dnSpy, lo que iniciará automáticamente el proceso de descompilación.

![[Pasted image 20251114094314.png]]

Para ver el código fuente de este ejecutable, tendremos que expandir el árbol de navegación del ensamblado _de prueba_ y seleccionar _test.exe_ , _dotnetapp_ y luego _Program_ , como se muestra en la Figura 33. Según la salida, el proceso de descompilación se realizó correctamente.

![[Pasted image 20251114094332.png]]

¡Excelente! Hemos descompilado correctamente el ejecutable.

#### Referencias cruzadas

Al analizar y depurar aplicaciones más complejas, una de las funciones más útiles de un descompilador es la capacidad de encontrar [referencias cruzadas](https://en.wikipedia.org/wiki/Cross-reference) a una variable o función específica. Podemos usar estas referencias cruzadas para comprender mejor la lógica del código. Por ejemplo, podemos supervisar el flujo de ejecución de forma estática o establecer [puntos de interrupción](https://en.wikipedia.org/wiki/Breakpoint) estratégicos para depurar e inspeccionar la aplicación. Podemos demostrar la eficacia de las referencias cruzadas en este proceso con un ejemplo sencillo.

Supongamos que, al analizar nuestra aplicación de destino DotNetNuke, observamos algunos valores codificados en Base64 en las solicitudes HTTP capturadas por Burp Suite. Dado que nos interesa comprender mejor dónde se decodifican y procesan estos valores dentro de nuestra aplicación de destino, podríamos suponer que cualquier función que maneje valores codificados en Base64 contiene la palabra "base64".

Partiremos de esta premisa y comenzaremos a buscar estas funciones en dnSpy. Para un análisis exhaustivo, deberíamos abrir todos los módulos .NET cargados por la aplicación web en nuestro descompilador. Sin embargo, para este ejercicio, solo abriremos el módulo principal de DNN, **C:\inetpub\wwwroot\dotnetnuke\bin\DotNetNuke.dll**

 , y buscaremos el término «base64» en los nombres de los métodos, como se muestra en la Figura 34.
 
![[Pasted image 20251114094429.png]]


El resultado de la búsqueda nos proporciona una lista de nombres de métodos que contienen el término "base64" (que se muestra en la Figura 35).

![[Pasted image 20251114094500.png]]

Escojamos una de las funciones e intentemos encontrar sus referencias cruzadas. Seleccionaremos la función _Base64UrlDecode_ haciendo clic con el botón derecho sobre ella y seleccionando _Analizar_ en el menú contextual.

![[Pasted image 20251114094551.png]]

Los resultados deberían aparecer en la ventana _del Analizador_ . En concreto, al expandir el nombre de la función se muestran dos opciones: _Usado por_ y _Usos_ (Figura 37).

![[Pasted image 20251114094611.png]]

Como su nombre indica, el nodo _«Usado por»_ se expande para mostrar dónde se llama a nuestra función de ejemplo dentro de la DLL de destino. Esto resulta extremadamente útil al analizar el código fuente. Si ahora hacemos clic en la referencia cruzada, dnSpy muestra la ubicación de la llamada a la función en el código fuente (Figura 38).

![[Pasted image 20251114094655.png]]

#### Modificación de ensamblajes

Finalmente, demostremos cómo modificar ensamblados de forma arbitraria. Podemos usar esta técnica para agregar instrucciones de depuración a un archivo de registro o alterar los atributos de un ensamblado para depurar mejor nuestra aplicación.

Para demostrar esta técnica, volveremos brevemente a nuestro archivo ejecutable personalizado anterior y lo editaremos usando dnSpy. Hagamos clic con el botón derecho en _Programa_ y seleccionemos _Editar clase_ (Figura 39).

![[Pasted image 20251114094727.png]]

Luego cambiaremos "Tu respuesta fue: " por "Dijiste: " (Figura 40).

![[Pasted image 20251114094804.png]]
![[Pasted image 20251114094825.png]]

Y finalmente, haremos clic en _Compilar_ y luego _en Archivo_ > _Guardar todo_ para sobrescribir la versión original del archivo ejecutable (Figura 41 y Figura 42).

![[Pasted image 20251114094934.png]]

![[Pasted image 20251114094953.png]]

![[Pasted image 20251114095001.png]]

Si volvemos a nuestro símbolo del sistema y volvemos a ejecutar **test.exe** , la segunda instrucción de impresión ahora es "Usted dijo: " (Figura 43).

![[Pasted image 20251114095027.png]]

Mediante una aplicación de ejemplo muy básica, hemos demostrado cómo recuperar el código fuente de aplicaciones basadas en .NET y cómo encontrar referencias cruzadas con la ayuda de nuestro descompilador preferido. También hemos demostrado cómo modificar y guardar un archivo de ensamblado .NET. Aunque esta modificación no parezca especialmente útil, resultará práctica más adelante en el curso cuando tengamos que modificar los atributos de los ensamblados para depurar mejor nuestra aplicación.

### 1.3.2. Descompilación de clases Java

Aunque existen muchas herramientas para descompilar bytecode de Java (con resultados diversos), en este curso utilizaremos el descompilador JD-GUI . Las aplicaciones web basadas en Java se componen principalmente de archivos de clase Java compilados que se comprimen en un único archivo, un archivo JAR (Java Archive). Con JD-GUI, podemos extraer los archivos de clase y, posteriormente, descompilarlos para obtener el código fuente Java.

Vamos a demostrar la descompilación en JD-GUI con un archivo JAR de prueba. Crearemos el archivo JAR/test.java en nuestra máquina Kali:

```java
import java.util.*;

public class test{
	public static void main(String[] args){
		Scanner scanner = new Scanner(System.in);
		System.out.println("What is your favorite Web Application Language?");
		String answer = scanner.nextLine();
		System.out.println("Your answer was: " + answer);
	}
}
```

Esta aplicación básica de Java solicita al usuario su idioma preferido e imprime la respuesta en la consola. Como parte del proceso de compilación, también configuramos las versiones de Java de origen y destino a la 1.8, que es la versión recomendada a largo plazo por Oracle (Listado 10).

 >Para esta sección, necesitaremos un Kit de Desarrollo de Java (JDK) para compilar el código fuente Java. Si aún no está instalado, podemos instalarlo en Kali con el comando "sudo apt install default-jdk".

```java
javac -source 1.8 -target 1.8 test.java
```

![[Pasted image 20251114095600.png]]

Tras compilar el código fuente, el archivo test.class se guarda en el directorio JAR . Para empaquetar la clase como un archivo JAR, necesitamos crear un archivo de manifiesto . Esto se logra fácilmente creando el directorio JAR/META-INF y añadiendo la clase de prueba al archivo MANIFEST.MF , como se muestra a continuación.

```
mkdir META-INF
```

```
echo "Main-Class: test" > META-INF/MANIFEST.MF
```

Ahora podemos crear nuestro archivo JAR ejecutando el siguiente comando:
```
jar cmvf META-INF/MANIFEST.MF test.jar test.class
```
![[Pasted image 20251114095707.png]]

Vamos a probar nuestra clase de ejemplo para asegurarnos de que funciona correctamente:
```
java -jar test.jar
```

![[Pasted image 20251114095743.png]]

>ESTO QUE SE HACE AHORA NO ES NECESARIO, SE PUEDE COPIAR Y PEGAR EL .jar

¡Genial! Ahora que sabemos que nuestro archivo JAR funciona, copiémoslo a la máquina que ejecuta JD-GUI. En nuestro laboratorio, se trata de la máquina virtual ManageEngine. Una forma sencilla de transferir archivos es mediante SMB con un script Impacket . En el directorio del archivo JAR , ejecutaremos el siguiente comando:

```shell
sudo impacket-smbserver test .
```

![[Pasted image 20251114095815.png]]

Con nuestro servidor Samba en funcionamiento, necesitamos conectarnos al servidor ManageEngine mediante xfreerdp . Consulte el material del curso para obtener las credenciales RDP correctas.

```shell
xfreerdp /v:manageengine /u:administrator /p:studentlab /cert:ignore /sec:rdp /size:1180x708
```

Una vez conectados al servidor ManageEngine, usaremos el Explorador de Windows para acceder a nuestro servidor Kali SMB mediante la ruta \\dirección-ip-de-tu-máquina-kali\test . A continuación, copiaremos test.jar al escritorio de la máquina virtual ManageEngine. Finalmente, abriremos JD-GUI mediante el acceso directo de la barra de tareas y arrastraremos el archivo JAR a su ventana.

![[Pasted image 20251114095907.png]]

En este punto, deberíamos poder usar el panel de navegación izquierdo para navegar al código descompilado en JD-GUI, como se muestra en la Figura 46.

![Figura 46: Navegando por el código fuente descompilado](https://static.offsec.com/offsec-courses/WEB-300/images/tools_&_methodologies/559b6df0ce7b00de5a995bc1a6f217c2-Picture31.png)

De forma similar al análisis de referencias cruzadas que realizamos con dnSpy, también podemos buscar métodos y variables arbitrarios en las clases descompiladas con JD-GUI. Sin embargo, la interfaz de usuario no es intuitiva y puede resultar engorrosa al usarla con aplicaciones grandes y complejas.

![[Pasted image 20251114095950.png]]

Presentaremos técnicas para superar estas limitaciones en un módulo posterior.
#### Ejercicio

Intente descompilar y explorar archivos compilados adicionales de .NET y Java para familiarizarse con las interfaces de usuario de dnSpy y JD-GUI. Encontrará varios archivos JAR en el directorio **C:\Program Files (x86)\ManageEngine\AppManager12\working\classes** de la máquina de laboratorio de ManageEngine y módulos administrados de .NET en el directorio **C:\inetpub\wwwroot\dotnetnuke\bin** de la máquina DNN.

## 1.4. Metodología de análisis de código fuente

Una vez que obtenemos el código fuente, estamos listos para abordar el análisis del mismo, que sin duda es la técnica más difícil de dominar en nuestro flujo de trabajo. Esto se debe al uso generalizado de frameworks de terceros en las aplicaciones web modernas, lo que puede dificultar la comprensión del flujo de datos. Nuestro análisis se complica aún más por la variedad de prácticas y estilos de codificación.

Por ello, conviene dedicar un tiempo a explorar la aplicación web en un navegador para familiarizarnos con su funcionamiento antes de analizar el código fuente. Durante este proceso, debemos redirigir el tráfico del navegador a través de Burp Suite para analizar las solicitudes y respuestas HTTP generadas durante el uso normal de la aplicación. Así, podremos identificar las tecnologías empleadas y cómo la aplicación gestiona las rutas y la transmisión de datos. La información recopilada durante esta exploración nos ayudará a centrar mejor nuestro análisis del código fuente.

La superficie de ataque de una aplicación depende de muchos factores, como sus casos de uso previstos y su pila de software. Por ejemplo, una aplicación web que aloja contenido de usuario podría tener más casos de cross-site scripting (XSS) que una aplicación que transfiere archivos entre diferentes servidores. De igual forma, los lenguajes de programación y los frameworks también pueden influir en los tipos de vulnerabilidades que pueda tener la aplicación. Sin embargo, no debemos excluir automáticamente ningún tipo de vulnerabilidad de nuestro análisis.

### 1.4.1. Un enfoque para el análisis

Al analizar el código fuente de una aplicación, debemos tener en cuenta _las fuentes_ y _los destinos_ . Los datos entran en una aplicación a través de una fuente y se utilizan (o se procesan) en un destino.

Consideremos un flujo de inicio de sesión típico. Enviamos un nombre de usuario y una contraseña a la aplicación mediante una solicitud POST. El código que procesa esta solicitud POST es la fuente. Este código puede validar los valores de nombre de usuario y contraseña y, posteriormente, ejecutar una consulta a la base de datos con dichos valores. La llamada a la base de datos para ejecutar la consulta es el destino en este caso.

Nuestro enfoque para el análisis manual del código fuente variará dependiendo de si elegimos comenzar con el examen de las fuentes o de los destinos.

En un enfoque de arriba hacia abajo, primero identificaríamos las fuentes. Si no tenemos acceso autenticado a la aplicación web, obviamente comenzaríamos a buscar vulnerabilidades en recursos no autenticados. Rastreando el flujo de la aplicación hasta sus respectivos destinos, intentaríamos identificar cualquier funcionalidad sensible y determinar qué controles están implementados (como la validación de entrada).

En un enfoque ascendente, primero identificaríamos los receptores de llamadas. Nuestro objetivo sería determinar si alguno de ellos contiene vulnerabilidades y qué variables o valores utiliza el código vulnerable. A continuación, tendríamos que determinar cómo la aplicación llama a la función vulnerable y rastrear el flujo de la aplicación hasta su origen. Al igual que con el enfoque descendente, debemos tener en cuenta cualquier filtro o saneamiento de entrada que pueda afectar la carga útil necesaria para explotar la función vulnerable.

Un enfoque ascendente suele revelar vulnerabilidades de mayor gravedad con menor probabilidad de exposición. En cambio, un enfoque descendente suele descubrir vulnerabilidades de menor gravedad con mayor probabilidad de exposición. Por ejemplo, las vulnerabilidades descubiertas con un enfoque ascendente podrían permitir a los administradores ejecutar código de forma remota. Por otro lado, las vulnerabilidades descubiertas con un enfoque descendente podrían permitir a cualquier usuario explotar ataques de secuencias de comandos entre sitios (XSS).

Por ello, es posible que debamos adaptar nuestro enfoque si buscamos un tipo de vulnerabilidad específico o variarlo según lo que encontremos en una aplicación determinada. Estos enfoques no deben ser rígidos. Con el tiempo y la práctica, aprenderemos la valiosa habilidad de adaptar nuestras metodologías y modificar nuestras técnicas.

Independientemente del enfoque que utilicemos, nuestros objetivos finales son los mismos: queremos identificar vulnerabilidades o errores lógicos en la aplicación, determinar cómo llamar al código vulnerable y sortear las restricciones.

### 1.4.2. Uso de un IDE

Un [_entorno de desarrollo integrado_](https://en.wikipedia.org/wiki/Integrated_development_environment) (IDE) es una herramienta potente para el análisis de código fuente. La mayoría de los IDE permiten realizar búsquedas y depuración de código avanzadas. Elegir el IDE «ideal» suele ser una cuestión de preferencia personal. En este curso, nos basamos principalmente en [_Visual Studio Code,_](https://code.visualstudio.com/) ya que admite múltiples lenguajes de programación mediante extensiones. Sin embargo, también utilizaremos herramientas especializadas como dnSpy. A medida que nuestra metodología personal evolucione, el proceso de elegir la herramienta más adecuada y aplicarla correctamente se volverá más natural.

Durante un análisis manual del código fuente, dedicaremos mucho tiempo a buscar en el código y a refinar nuestras búsquedas.

Comencemos con un ejemplo sencillo en el que intentaremos revisar la funcionalidad de inicio de sesión de una aplicación. Podríamos comenzar con una búsqueda de "contraseña".

![Figura 48: Búsqueda de contraseña](https://static.offsec.com/offsec-courses/WEB-300/images/sca/d3b5ba1562eedca0f1afabb8631c2b50-sca_search_01.png)

Esto produce muchos resultados a partir de varios tipos de archivos diferentes y, lamentablemente, muchos de los resultados son inútiles.

![Figura 49: Resultados de la búsqueda](https://static.offsec.com/offsec-courses/WEB-300/images/sca/67684ef06604286533c44c0464abd2c4-sca_search_02.png)

El siguiente paso dependerá de nuestra metodología. Podríamos revisar los archivos HTML para determinar cómo están configurados los formularios de inicio de sesión o de restablecimiento de contraseña. Los archivos JavaScript podrían contener lógica del lado del cliente o valores confidenciales. Sin embargo, también podríamos empezar con el código de la aplicación, que, en este ejemplo, son los archivos fuente Java.

En cualquier caso, podemos refinar nuestra búsqueda haciendo clic en el botón _"Mostrar/Ocultar detalles de búsqueda"_ (representado por tres puntos).

![Figura 50: Botón para alternar detalles de búsqueda](https://static.offsec.com/offsec-courses/WEB-300/images/sca/8d84460e9957dd5111b77e4c8a614f13-sca_search_03.png)

Con la opción Detalles de búsqueda activada, podemos refinar la búsqueda para incluir o excluir ciertos tipos de archivos. Por ejemplo, podríamos limitar la búsqueda solo a archivos Java introduciendo ".java" en el campo _Archivos a incluir_ . Como con cualquier filtro de búsqueda, conviene evitar el sobrefiltrado, ya que podría excluir resultados importantes y generar [falsos negativos](https://en.wikipedia.org/wiki/False_positives_and_false_negatives) . También podemos usar expresiones regulares en las búsquedas de Visual Studio Code. Lo demostraremos en un módulo posterior.

Si un término de búsqueda devuelve demasiados resultados, podemos usar palabras clave específicas de la aplicación para acotar la búsqueda. Algunas fuentes de palabras clave incluyen las páginas web de la aplicación, las solicitudes y los mensajes de error. Por ejemplo, si la página de inicio de sesión de una aplicación muestra el mensaje «Credenciales incorrectas», podemos buscar ese texto para encontrar dónde se produce el error y, a partir de ahí, descubrir la función de inicio de sesión.

Si identificamos una función vulnerable y necesitamos determinar dónde la utiliza la aplicación, podemos buscar "referencias" (en la mayoría de los IDE) para localizar los métodos o llamadas a funciones de la aplicación. Para ello, en Visual Studio Code, simplemente hacemos clic con el botón derecho en el nombre de una función o método para abrir un menú contextual y seleccionamos " _Buscar todas las referencias_ ".

![Figura 51: Buscar todas las referencias](https://static.offsec.com/offsec-courses/WEB-300/images/sca/41f8e3d8c31469be0c3db260b2c6a22a-sca_search_04.png)

Visual Studio Code muestra los resultados en la parte izquierda de la ventana.

![Figura 52: Resultados de referencia](https://static.offsec.com/offsec-courses/WEB-300/images/sca/4448fdb32baf2f1d6fe03e5d6486bdd4-sca_search_05.png)


### 1.4.3. Patrones comunes de enrutamiento HTTP

Dedicaremos mucho tiempo a analizar el código fuente para comprender cómo una aplicación recibe una solicitud HTTP y determina qué código ejecutar para generar la respuesta HTTP correspondiente. Esto se conoce como _enrutamiento HTTP_ . Esta información es importante independientemente del enfoque que adoptemos para el análisis del código fuente. Nuestro objetivo es rastrear el flujo de una solicitud a través de la aplicación. El servidor web, el lenguaje de programación y el framework que utiliza una aplicación influyen en su configuración de enrutamiento HTTP. Repasemos algunos patrones comunes de enrutamiento HTTP.

_El enrutamiento del sistema de archivos (FSR)_ asigna la URL de una solicitud a un archivo en el sistema de archivos del servidor. En este esquema, el servidor web define un _directorio raíz_ (también conocido como directorio web), donde almacena los archivos accesibles externamente. Por ejemplo, el servidor HTTP Apache en Ubuntu utiliza **`/var/www/html` como** [directorio raíz](https://httpd.apache.org/docs/2.4/urlmapping.html) predeterminado . Cuando el servidor recibe una solicitud HTTP, examina la ruta de la URL e intenta encontrar un archivo que coincida con la ruta en el directorio raíz. En otras palabras, si solicitamos **`http://example.com/funnyCats.html`** , el servidor servirá el archivo ubicado en **`/var/www/html/** funnyCats.html`. Si el servidor no puede encontrar ese archivo, responderá con un mensaje de error 404.

Algunas aplicaciones Java utilizan _mapeos de servlets_ para controlar cómo gestionan las solicitudes HTTP. En las aplicaciones web Java, "servlet" es una abreviatura de las clases que gestionan las solicitudes, como las HTTP. En general, implementan código que acepta una solicitud y devuelve una respuesta. Un archivo **web.xml** almacena la configuración de enrutamiento HTTP. Si bien puede haber varias entradas en un archivo **web.xml** , cada ruta se compone de dos entradas: una para definir un servlet y otra para asociar una URL a un servlet.

Veamos un ejemplo.

![[Pasted image 20251114100325.png]]

En este ejemplo, el archivo **web.xml** define un servlet con el ID "SubscriptionHandler" para la clase _org.opencrx.kernel.workflow.servlet.SubscriptionHandlerServlet_ . Una entrada "servlet-mapping" asigna la URL **/SubscriptionHandler/*** al servlet SubscriptionHandler. El asterisco (*) indica un comodín. La clase del servlet se encarga de analizar la ruta de la URL y decidir cómo gestionar las solicitudes HTTP.

Algunos lenguajes de programación y frameworks incluyen información de enrutamiento directamente en el código fuente. Por ejemplo, ExpressJS utiliza este método de enrutamiento:

![[Pasted image 20251114100518.png]]

Una variante de este enfoque es el enrutamiento mediante anotaciones o atributos. El framework [_Spring MVC_](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-controller) para Java y el framework [_Flask_](https://flask.palletsprojects.com/en/1.1.x/quickstart/#routing) para Python, entre otros, utilizan este enfoque. El código fuente declara una anotación o atributo junto al método o función que gestiona la solicitud HTTP.

![[Pasted image 20251114100539.png]]

En este ejemplo, el servidor llama al método _getUsersPage()_ cuando recibe una solicitud GET a la ruta URL **/admin/users** . También existen anotaciones que gestionan la asignación de solicitudes para diferentes métodos HTTP o rutas URI más complejas.

Estos son ejemplos básicos de enrutamiento HTTP. Cada lenguaje de programación y framework ofrece variaciones, pero la mayoría se asemejarán a los ejemplos anteriores. Exploraremos métodos de enrutamiento adicionales en otros módulos de este curso.

### 1.4.4. Análisis del código fuente en busca de vulnerabilidades

Creemos que no existe un sustituto adecuado para la revisión manual del código, ya que las herramientas automatizadas suelen pasar por alto muchos matices de codificación y rutas de código complejas que conducen a funciones vulnerables. Si bien no dependemos exclusivamente de herramientas automatizadas de análisis de código fuente, es importante mencionarlas, ya que cumplen una función. En concreto, estas herramientas suelen ser muy capaces de identificar vulnerabilidades fáciles de explotar, lo que permite ahorrar tiempo. En general, aunque también generan un gran número de falsos positivos en una aplicación determinada, incluso estos resultados pueden ayudarnos a identificar puntos muertos en el código, lo que, de nuevo, nos ahorra tiempo.

No cabe duda de que las revisiones manuales consumen mucho tiempo, pero el conocimiento adquirido mediante este proceso se va acumulando con el tiempo. Este conocimiento puede ayudarnos a descubrir vulnerabilidades más complejas que, de otro modo, podrían haber pasado desapercibidas.

Como en la mayoría de las pruebas de seguridad, nuestro objetivo es encontrar un equilibrio entre tiempo, esfuerzo y calidad. Es posible que, debido a las limitaciones de tiempo y la priorización, no detectemos vulnerabilidades en aplicaciones grandes durante las revisiones de código y las pruebas de penetración.

Por ejemplo, es común priorizar menos las bibliotecas y dependencias externas que los archivos fuente de la aplicación. Esta decisión se basa generalmente en la suposición de que una biblioteca externa podría tener una vulnerabilidad, pero que la aplicación analizada probablemente nunca utilizará la función vulnerable de la dependencia. Sin embargo, en aplicaciones pequeñas, priorizar el análisis de bibliotecas y dependencias externas puede aumentar la superficie de ataque si la aplicación depende en gran medida de ellas.

Teniendo esto en cuenta, existen muchos aspectos prioritarios a considerar al realizar un análisis manual del código fuente. Esta lista general se presenta sin un orden específico:

- Tras revisar las áreas no autenticadas, concéntrese en las áreas de la aplicación que probablemente reciban menos atención (es decir, las partes autenticadas de la aplicación).
- Investigue cómo se realiza la sanitización de la entrada del usuario. ¿Se realiza utilizando una biblioteca de código abierto confiable o se utiliza una solución personalizada?
- Si la aplicación utiliza una base de datos, ¿cómo se construyen las consultas? ¿La aplicación parametriza la entrada o simplemente la limpia?
- Analice la lógica de las rutinas de creación de cuentas o de restablecimiento/recuperación de contraseñas. ¿Es posible vulnerar su funcionalidad?
- ¿La aplicación interactúa con su sistema operativo? Si es así, ¿podemos modificar los comandos o inyectar otros nuevos?
- ¿Existen vulnerabilidades específicas de cada lenguaje de programación?

Esta lista podría ampliarse exponencialmente. Abordaremos estos temas y otros más a lo largo del curso. La metodología personal y la profundidad del conocimiento para el análisis manual de código fuente se desarrollan con el tiempo. Analizar el código fuente para identificar vulnerabilidades nos ayudará a construir nuestra propia metodología. Al comprender cómo se codifican estas vulnerabilidades, podemos aplicar nuestro conocimiento a otras aplicaciones, incluso a aquellas de código cerrado.

## 1.5. Depuración

Una de las mejores maneras de comprender una aplicación es ejecutarla mediante un depurador, lo que nos permite inspeccionar la memoria y las pilas de llamadas. Esta información puede ser invaluable al diseñar un exploit. Algunos depuradores también permiten depurar un proceso que se ejecuta en un sistema remoto. Esto se conoce como depuración remota .

> La depuración revela el funcionamiento interno de la aplicación en tiempo de ejecución. Para obtener información similar de las bases de datos, podemos habilitar el registro de consultas mientras probamos la aplicación. Utilizaremos el registro de consultas en otros módulos.

Vamos a intentar depurar una aplicación Java sencilla usando Visual Studio Code. Necesitaremos instalar dos complementos: RedHat [_Language Support for Java_](https://marketplace.visualstudio.com/items?itemName=redhat.java) y Microsoft [_Debugger for Java_](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-debug) .

Vamos a crear una aplicación Java de ejemplo que genere un número aleatorio y nos pida que lo adivinemos. Crearemos un nuevo directorio llamado **debug** y un archivo llamado **DebuggerTest.java** que contendrá el siguiente código:

```java
import java.util.Random;
import java.util.Scanner;

public class DebuggerTest {

  private static Random random = new Random();
  public static void main(String[] args){
    int num = generateRandomNumber();
		Scanner scanner = new Scanner(System.in);
		System.out.println("Guess a number between 1 and 100.");
		try{
      int answer = scanner.nextInt();
      scanner.close();
      System.out.println("Your guess was: " + answer);
      if(answer == num) {
        System.out.println("You are correct!");
      } else {
        System.out.println("Incorrect. The answer was " + num);
      }
    } catch(Exception e) {
      System.out.println("That's not a number.");
    } finally {
      scanner.close();
    }
    System.exit(0);
  }

  public static int generateRandomNumber() {
    return random.nextInt(100)+1;
  }
}
```

Podemos depurar esta aplicación directamente desde nuestro IDE, pero primero necesitamos establecer un punto de interrupción haciendo clic a la izquierda de los números de línea. Establezcamos uno en la línea 8.

![[Pasted image 20251114100818.png]]

Aparecerá un punto rojo junto al número de línea en la ubicación de nuestro punto de interrupción. Ahora que hemos establecido un punto de interrupción, podemos depurar la aplicación haciendo clic en _Ejecutar_ y, a continuación, _en Ejecutar y depurar_ .

![[Pasted image 20251114100837.png]]

El depurador ejecutará nuestro código hasta que alcance el punto de interrupción. Una vez que la ejecución llegue al punto de interrupción, el programa se pausará y nuestro IDE resaltará la línea donde se detuvo la ejecución.

![[Pasted image 20251114100900.png]]

También tenemos un nuevo menú contextual de depuración. Los botones, de izquierda a derecha, son: _Continuar_ , _Paso a paso_ , _Entrar en_ , _Salir_ , _Reiniciar_ , _Detener_ y _Reemplazar código en caliente_ . Analicemos brevemente cada uno de ellos.

Si hacemos clic en _Continuar_ , la aplicación reanudará su ejecución hasta que finalice o alcance otro punto de interrupción. _La opción Paso a_ paso permite que se ejecute la siguiente llamada al método y pausará la ejecución en la siguiente línea del método actual. En nuestro caso, se ejecutaría la llamada a ` _generateRandomNumber()`_ y se pausaría al regresar a la línea 9. La opción _Paso a paso dentro_ seguiría el flujo de ejecución hasta _`generateRandomNumber()`_ y se pausaría en la línea 28. La _opción Salir_ permite que el método actual se ejecute y se pausa al retroceder un nivel. Si pulsamos _Salir_ mientras la ejecución está pausada en el método _`main()`_ , la ejecución finalizará. Si la pulsamos mientras estamos en el método _`generateRandomNumber()`_ , la ejecución regresará a _`main()`_ y se pausará de nuevo. _Las opciones Reiniciar_ y _Detener_ son autoexplicativas.

_La función Hot Code Replace_ permite modificar el archivo fuente y enviar los cambios al proceso en ejecución. Sin embargo, esta característica no está disponible en todos los lenguajes de programación.

Hagamos clic en Step Over.

![[Pasted image 20251114101008.png]]

El depurador ha pausado la ejecución en la línea 9 y la ventana Variables se ha actualizado para mostrar el valor de la variable _`num`_ . También podemos obtener el valor de una variable colocando el cursor del ratón sobre ella. Hagamos clic en _Continuar_ para permitir que la aplicación se ejecute. Ahora podemos predecir el número correcto cada vez que juguemos.

### 1.5.1. Depuración remota

La depuración remota nos permite depurar un proceso que se ejecuta en un sistema diferente siempre que tengamos acceso al código fuente y al puerto del depurador en el sistema remoto.

Probémoslo en una aplicación Java. El archivo JAR y un archivo ZIP con el código fuente están disponibles en la máquina virtual Wiki, a la que se puede acceder desde la página _de Laboratorios_ . Extraeremos el archivo ZIP, añadiremos los archivos a Visual Studio Code haciendo clic en _Archivo_ > _Abrir carpeta_ y, a continuación, seleccionaremos el directorio  **NumberGame extraído.**

![[Pasted image 20251114101050.png]]

Abramos **MainController.java** y establezcamos un punto de interrupción en la línea 22. Es posible que nuestro IDE subraye algunas importaciones u objetos del archivo, ya que no hemos configurado la ruta de compilación. Aun así, deberíamos poder depurar el código. Sin embargo, si la aplicación ejecuta código desde un archivo fuente que no tenemos, no podremos seguir la ejecución en ese archivo.

Agreguemos las dependencias a VS Code. Podemos extraerlas del archivo JAR. La anotación _`@SpringBootApplication`_ en **`NumberGameApplication.java`** indica que se trata de una aplicación Spring Boot. Podemos encontrar las dependencias en **`/BOOT-INF/lib/`** dentro del archivo JAR. VS Code debería importar automáticamente las dependencias si las colocamos en un directorio **`lib` dentro del directorio** **`NumberGame`**.

```shell
unzip -j NumberGame.jar "BOOT-INF/lib/*" -d NumberGame/lib/
```

![[Pasted image 20251114101323.png]]

Una vez extraídas las dependencias, VS Code debería poder resolverlas todas. Podemos verificar que las dependencias se cargaron correctamente haciendo clic en _«Proyecto Java»_ en la sección inferior izquierda de VS Code.

![[Pasted image 20251114101342.png]]

Una vez que se expande el panel Proyectos Java, podemos hacer clic en _Proyecto y Dependencias externas_ para expandir la lista de dependencias y verificar que los archivos JAR extraídos estén listados.

![[Pasted image 20251114101354.png]]

Si los archivos JAR no aparecen en la lista, podemos agregarlos manualmente haciendo clic en el botón _+_ junto a Dependencias del proyecto y externas y seleccionándolos en la ventana de archivos resultante.

Ahora que hemos añadido las dependencias, necesitaremos un archivo **launch.json** para realizar la depuración remota. Visual Studio Code lo creará automáticamente si hacemos clic en el acceso directo _Ejecutar_ y luego en _Crear un archivo launch.json_.

![[Pasted image 20251114101413.png]]

Tras unos instantes, **launch.json** debería abrirse en una ventana del editor. Si no se abre, podemos encontrar el archivo en el directorio **.vscode** . Podemos ignorar la configuración predeterminada. Crearemos una nueva configuración para la depuración remota haciendo clic en _Agregar configuración..._ y luego _en Java: Conectar a programa remoto_ en el menú emergente.

>ESTE ARCHIVO DEBE DE ESTAR AFUERA DEL DIRECTORIO

![[Pasted image 20251114101443.png]]

Necesitamos actualizar el valor de "hostName" a "127.0.0.1" y el valor de "port" a 9898. Luego guardaremos los cambios.

![[Pasted image 20251114101512.png]]

Una vez configurado **launch.json** , podemos ejecutar el archivo JAR con la depuración habilitada. Incluiremos la **opción `-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9898`** para [habilitar la depuración](https://docs.oracle.com/javase/8/docs/technotes/guides/jpda/conninv.html#Invocation) en el puerto 9898. Dado que solo especificamos un número de puerto en la opción _`address`_ , el socket de depuración solo escuchará en localhost.

```shell
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=9898 -jar ~/NumberGame.jar
```

![[Pasted image 20251114101710.png]]

Ahora que la aplicación se ha iniciado, podemos acceder a ella en el puerto 8000 con nuestro navegador.

![[Pasted image 20251114101905.png]]

Antes de enviar un valor, iniciemos el depurador. En VS Code, debemos hacer clic en el botón _Ejecutar_ si la vista Ejecutar no está abierta. Luego, haremos clic en el menú desplegable junto a la flecha verde y seleccionaremos _Adjuntar a programa remoto_.

![[Pasted image 20251114101923.png]]

Ahora que hemos seleccionado la configuración que deseamos, podemos iniciar el depurador haciendo clic en el botón _Iniciar depuración_ (la flecha verde).

Según nuestra configuración, es posible que aparezca una ventana emergente que nos solicite cambiar el servidor de lenguaje Java para que se ejecute en modo estándar. Podemos hacer clic en _Sí_ en esta ventana emergente.

![[Pasted image 20251114101939.png]]

Una vez que el depurador haya establecido una conexión con el programa remoto, se abrirá el menú contextual de depuración. Podemos verificar que todo funciona correctamente introduciendo un número en la página web y comprobando si el depurador se detiene en nuestro punto de interrupción.

![[Pasted image 20251114102010.png]]

El depurador alcanzó el punto de interrupción y pausó la ejecución. Hagamos clic en _Paso a paso_ dos veces para interrumpir la ejecución en la línea 26. Haremos clic en _«Controlador principal»_ en la ventana Variables para encontrar el valor de la variable _de respuesta_ .

